<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        :root { --BorderRadius: 2px; --LeftGutter: 0px; --LineLeftOffset: 1px; --BottomGap: 12px; --BarsHoursGap: 8px; --ExtremeLabelGap: 10px; --GradientCurrent: linear-gradient(to top, #FF8000, #FF0000); --HoursH: 20px; --PricesH: 20px; --HoursPad: 0.25em; --TopPad: 2px; --GradientScale: 1; }
        body {
            overflow: hidden; /* verhindert Scrollbalken innerhalb der Kachel */
            color: var(--content-color, var(--font-color));
        }

        #block {
            height: 100%;
            max-height: 100%;
            position: relative;
            overflow: hidden; /* verhindert Scrollbalken im Container */
        }

        #bars {
            display: flex;
            align-items: flex-end;
            padding-top: var(--TopPad);
            height: calc(100% - var(--PricesH) - var(--HoursH) - var(--BottomGap) - var(--BarsHoursGap)); /* dynamisch: Preise + Stunden abziehen */
            position: relative;
            overflow: hidden; /* verhindert, dass Baseline/Fill den Container nach unten erweitern */
        }

        /* Linken Rand für Preislabels reservieren (nur Inhalt, nicht Overlay) */
        #bars, #hours {
            padding-left: var(--LeftGutter);
            box-sizing: border-box;
        }

        #prices {
            height: var(--PricesH);
            margin-left: 5px;
            margin-top: var(--BottomGap);
            font-size: var(--FontSizePrices);
        }

        #bars > div {
            flex: var(--CountBars);
            margin-bottom: 1px;
            margin-left: 1px;
            margin-right: 1px;
            text-align: right;
            font-size: var(--FontSizeBars);
            writing-mode: vertical-lr;
            color: var(--FCBars);
            border-top-left-radius: var(--BorderRadius);
            border-top-right-radius: var(--BorderRadius);
            display: block;
            height: 100%;
            text-overflow: clip; 
            white-space: nowrap; 
            background-image: none;
            background-color: transparent;
            position: relative;
        }

        /* Innerer Füllbalken, wächst relativ zur Nulllinie (Baseline) */
        #bars > div .bar-inner {
            position: absolute;
            left: 0;
            width: 100%;
            height: 0%;
            background-image: var(--Gradient, linear-gradient(to top, #28cdab, #1d8b75));
            /* Einheitliche Gradienten-Skalierung über die gesamte Balkenhöhe */
            background-repeat: no-repeat;
            background-position: left bottom;
            background-size: 100% calc(var(--BarsHeightPx, 100%) * var(--GradientScale, 1));
            opacity: 1;
            z-index: 1;
        }
        /* Aktuelle Stunde: eigener Farbverlauf */
        #bars > div.current-hour .bar-inner {
            background-image: var(--GradientCurrent, var(--Gradient, linear-gradient(to top, #28cdab, #1d8b75)));
        }

        /* 15-Minuten: jeden zweiten Balken leicht abdunkeln (10% Schwarz-Overlay) */
        /* Nur bei Balken mit Preisinformationen anwenden */
        #bars > div:not([data-nodata="1"]) .bar-inner.shaded::after {
            content: "";
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.05);
            border-top-left-radius: inherit;
            border-top-right-radius: inherit;
            border-bottom-left-radius: inherit;
            border-bottom-right-radius: inherit;
            pointer-events: none;
        }

        /* Horizontale Nulllinie für negative Preise */
        #baseline {
            position: absolute;
            left: 0;
            width: 100%;
            height: 0px;
            border-top: 1px dashed var(--content-color);
            opacity: 0.25; /* 50% transparent */
            z-index: 1;
        }

        /* Level-Indikator je Balken genau auf der Nulllinie */
        #bars > div .level-marker {
            position: absolute;
            left: 0;
            width: 100%;
            height: 0; /* Linie über border-top */
            border-top: 0 solid transparent; /* wird dynamisch gesetzt */
            z-index: 2; /* über dem Füllbalken */
            pointer-events: none;
        }

        #hours {
            display: flex;
            margin-bottom: 0;
            margin-top: var(--BarsHoursGap);
            height: var(--HoursH); /* dynamische Höhe gemäß Text */
            text-align: var(--TextAlignHours);
            font-size: var(--FontSizeHours);

        }

        #hours > div {
            flex: var(--HourAhead);
            margin-left: 1px;
            margin-right: 1px;
            writing-mode: var(--WriteMode);
            position: relative; /* für Overlay-Hintergrund */
            border-radius: 3px; /* optische Abrundung bleibt erhalten */
            box-sizing: border-box; /* Padding in Größe einbeziehen */
            z-index: 0; /* Stacking-Kontext für Overlay hinter dem Text */
            display: flex;              /* Text in der Box zentrieren */
            align-items: center;        /* vertikal zentriert */
            justify-content: center;    /* horizontal zentriert */
            /* Vertikales Padding in jeder Stundenbox, skaliert mit Schriftgröße */
            padding-top: var(--HoursPad, 0.5em);
            padding-bottom: var(--HoursPad, 0.5em);
        }

        /* Transparenter Hintergrund nur per Overlay, Text bleibt voll sichtbar */
        #hours > div::before {
            content: "";
            position: absolute;
            inset: 0;
            background-color: var(--BGCHour);
            opacity: 0.2; /* alle außer der ersten Stunde: 80% transparent */
            border-radius: 3px;
            pointer-events: none; /* keine Interaktion blockieren */
            z-index: -1; /* hinter dem Text platzieren */
        }

        /* Erste Stunde mit vollem Hintergrund */
        #hours > div.current::before {
            opacity: 1;
        }

        
        /* Overlay für Stunden-Durchschnittswerte */
        #avgoverlay {
            position: absolute;
            top: var(--TopPad);
            left: 0;
            width: 100%;
            height: calc(100% - var(--PricesH) - var(--HoursH) - var(--BottomGap) - var(--BarsHoursGap) - var(--TopPad)); /* gleiche Höhe wie #bars, inklusive Abstand zwischen Balken und Stunden */
            pointer-events: none; /* Overlay nicht klick-blockierend */
            z-index: 2;
            overflow: hidden; /* Inhalt bleibt innerhalb, Labels werden geclamped */
        }
        #avgoverlay .avglabel {
            position: absolute;
            bottom: 5px; /* etwas Abstand (5px) vom unteren Rand der Balken */
            writing-mode: vertical-lr;
            transform: translateX(-50%);
            color: var(--FCBars);
            font-size: var(--FontSizeBars);
            text-align: center;
            white-space: nowrap;
            padding-bottom: 5px;
        }
        /* Horizontale Rasterlinien (max + alle 5ct) im Overlay */
        #avgoverlay .gridline {
            position: absolute;
            left: calc(var(--LeftGutter) + var(--LineLeftOffset));
            width: calc(100% - var(--LeftGutter) - var(--LineLeftOffset));
            border-top: 1px dashed var(--content-color);
            opacity: 0.25; /* 75% transparent */
        }
        #avgoverlay .gridline.gridline-max {
            border-top: 1px solid var(--content-color);
            opacity: 0.25; /* 75% transparent */
            left: 0;                /* min/max bis zum linken Rand */
            width: 100%;            /* volle Breite */
        }
        #avgoverlay .gridline.gridline-zero {
            border-top: 1px dashed var(--content-color);
            opacity: 0.25; /* 50% transparent */
        }
        #avgoverlay .gridprice {
            position: absolute;
            left: 0;
            width: calc(var(--LeftGutter) - 10px);
            padding-right: 2px;
            text-align: right;
            transform: translateY(-50%);
            transform-origin: 100% 50%; /* skalieren um die vertikale Mitte neben der Linie */
            color: var(--content-color);
            font-size: var(--FontSizeScale, var(--FontSizeBars));
            white-space: nowrap;
            writing-mode: horizontal-tb;
        }
    </style>
  <!--             color: var(--FCHourDefault);

                color: var(--FCHour);
 -->

</head>
<body>
    <div id="block">
        <div id="bars">
            <!-- Will be filled through JavaScript -->
        </div>
        <div id="avgoverlay"></div>
        <div id="hours">
            <!-- Will be filled through JavaScript -->
        </div>
        <div id="prices">  
            <span>Aktuell: <span id="price_cur"></span></span>
            <span style="color: green;">&nbsp;&nbsp;&nbsp;&darr; <span id="price_min"></span></span>
            <span style="color: red;">&nbsp;&nbsp;&nbsp;&uarr; <span id="price_max"></span></span>
            <span>&nbsp;&nbsp;&nbsp;&Oslash;<span id="price_avg"></span></span>

        </div>
    </div>
    <script type="text/javascript" charset="UTF-8">

        // Globaler Stub: fängt frühe Aufrufe von handleMessage ab
        window._pendingMessages = window._pendingMessages || [];
        if (typeof window.handleMessage !== 'function') {
            window.handleMessage = function(msg) {
                try { window._pendingMessages.push(msg); } catch(e) {}
            };
        }


        let BarGradient;
        let BarColor;
        let HourAhead;
        let UseSkinColor;
        let UseDefaultColorHour;

        try {
            const qp = new URLSearchParams(window.location.search || '');
            const tc = qp.get('textcolor');
            if (tc) {
                document.documentElement.style.setProperty('--font-color', tc);
            }
        } catch (e) {
            // ignore if not available
        }

        // 15-Minuten-Visualisierung
        let BarsPerHour = 4;
        // sichere Defaults, werden durch Messages überschrieben
        let BarPriceRound = 2;
        let VisCent = ' ct';
        let ShowCtSuffix = true;
        let Scale = 1;
        let UseCurrentColorHour = '#ffffff';
        // Sichtbarkeiten (vom Backend konfigurierbar)
        let BarShowPrices = true; // Preise in den Balken
        let ShowGrid = true;      // Rasterlinien + Preislabels im Overlay
        let OnlyPriceBars = false; // nur Balken mit Preis-Info anzeigen
        let OptimizeGradient = false; // OKLCH-Optimierung per Toggle
        let ScaleGradientByLevel = true; // Verlaufsskalierung per Preislevel
        let LastGradientCsv = '';
        let LastGradientCurrentCsv = '';
        const DefaultGradientCsv = '#28cdab, #1d8b75';
        const DefaultGradientCurrentCsv = '#FF8000, #FF0000';
        // Referenz auf :root für CSS-Variablen
        const root = document.documentElement;
        // Aktuellen Preis (aus Backend-Variable) puffern und bevorzugt anzeigen
        let LastActPrice = null;
        // Overlay-Cache für stabile Positionierung
        let lastHoursToShow = 0;
        let lastHourAverages = [];
        let lastBarsPerHour = BarsPerHour;
        let lastTotalBars = 96;
        let lastTotalHours = 24;
        let lastBaselineTopPct = 100; // Prozent von oben, Position der Nulllinie
        let lastLocalMin = 0;
        let lastLocalMax = 1;
        let lastLeftGutterPx = 0;
        // Indizes der Balken mit globalem Min/Max für die aktuelle Ansicht
        let lastIndexMinBar = -1;
        let lastIndexMaxBar = -1;
        // Pro Stunde: gibt es valide (!=0) Daten in dieser Stunde?
        let lastHourHasData = [];
        // Zuletzt gerenderter Datensatz für spätere Neupositionierung
        let lastDataset = [];

        // Helper: OKLCH-Gradient-Unterstützung prüfen und passenden String bauen
        function supportsBgImage(val) {
            try { return !!(window.CSS && CSS.supports && CSS.supports('background-image', val)); } catch(e) { return false; }
        }
        // JS-Fallback: Interpolation in OKLCH im Script und Ausgabe als sRGB-Mehrfachstops
        function buildPerceptualGradientCsv(colorsCsv, steps = 9) {
            try {
                const parts = String(colorsCsv).split(',').map(s => s.trim()).filter(Boolean);
                if (parts.length < 2) return '';
                // Unterstütze nur einfache Hex-Farben (#RRGGBB) als Fallback-Eingabe
                const hexRe = /^#?([0-9a-fA-F]{6})$/;
                const hexToRgb = (hex) => {
                    const m = hexRe.exec(hex);
                    if (!m) return null;
                    const n = parseInt(m[1], 16);
                    return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
                };
                const srgbToLinear = (c) => {
                    c = c / 255;
                    return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                };
                const linearToSrgb = (c) => {
                    return c <= 0.0031308 ? (12.92 * c) : (1.055 * Math.pow(c, 1/2.4) - 0.055);
                };
                const rgbToOklab = (r8,g8,b8) => {
                    const r = srgbToLinear(r8);
                    const g = srgbToLinear(g8);
                    const b = srgbToLinear(b8);
                    const l = 0.4122214708*r + 0.5363325363*g + 0.0514459929*b;
                    const m = 0.2119034982*r + 0.6806995451*g + 0.1073969566*b;
                    const s = 0.0883024619*r + 0.2817188376*g + 0.6299787005*b;
                    const l_ = Math.cbrt(l), m_ = Math.cbrt(m), s_ = Math.cbrt(s);
                    const L = 0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_;
                    const a = 1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_;
                    const bb= 0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_;
                    return {L, a, b: bb};
                };
                const oklabToRgb = (L,a,b) => {
                    const l_ = L + 0.3963377774*a + 0.2158037573*b;
                    const m_ = L - 0.1055613458*a - 0.0638541728*b;
                    const s_ = L - 0.0894841775*a - 1.2914855480*b;
                    const l = l_*l_*l_;
                    const m = m_*m_*m_;
                    const s = s_*s_*s_;
                    let r =  4.0767416621*l - 3.3077115913*m + 0.2309699292*s;
                    let g = -1.2684380046*l + 2.6097574011*m - 0.3413193965*s;
                    let bb= -0.0041960863*l - 0.7034186147*m + 1.7076147010*s;
                    r = Math.min(1, Math.max(0, r));
                    g = Math.min(1, Math.max(0, g));
                    bb= Math.min(1, Math.max(0, bb));
                    const R = Math.round(Math.min(255, Math.max(0, linearToSrgb(r)*255)));
                    const G = Math.round(Math.min(255, Math.max(0, linearToSrgb(g)*255)));
                    const B = Math.round(Math.min(255, Math.max(0, linearToSrgb(bb)*255)));
                    return {R,G,B};
                };
                const toOklch = ({L,a,b}) => {
                    const C = Math.hypot(a,b);
                    let h = Math.atan2(b, a) * 180 / Math.PI;
                    if (h < 0) h += 360;
                    return {L, C, h};
                };
                const fromOklch = ({L,C,h}) => {
                    const hr = (h * Math.PI) / 180;
                    const a = C * Math.cos(hr);
                    const b = C * Math.sin(hr);
                    return {L, a, b};
                };
                const fmtHex = ({R,G,B}) => '#' + [R,G,B].map(v=>v.toString(16).padStart(2,'0')).join('');
                const parseStops = parts.map(p => hexToRgb(p)).filter(Boolean);
                if (parseStops.length !== parts.length) return '';
                const oklchStops = parseStops.map(rgb => toOklch(rgbToOklab(rgb.r, rgb.g, rgb.b)));
                const segs = oklchStops.length - 1;
                const out = [];
                for (let s = 0; s < segs; s++) {
                    const a0 = oklchStops[s];
                    const a1 = oklchStops[s+1];
                    // kürzere Hue-Richtung
                    let dh = ((a1.h - a0.h + 540) % 360) - 180;
                    for (let i = 0; i < steps; i++) {
                        const t = i / (steps - 1);
                        const L = a0.L + t*(a1.L - a0.L);
                        const C = a0.C + t*(a1.C - a0.C);
                        let h = a0.h + t*dh; if (h < 0) h += 360; else if (h >= 360) h -= 360;
                        const rgb = oklabToRgb(...Object.values(fromOklch({L,C,h})));
                        const pos = ((s + t) / segs) * 100;
                        out.push(fmtHex(rgb) + ' ' + pos.toFixed(2) + '%');
                    }
                }
                return out.join(', ');
            } catch(e) { return ''; }
        }
        function buildGradientToTop(colorsCsv) {
            // Erst OKLCH mit 'shorter hue' versuchen, dann ohne, am Ende sRGB-Fallback
            const cands = [
                'linear-gradient(in oklch shorter hue, to top, ' + colorsCsv + ')',
                'linear-gradient(to top in oklch shorter hue, ' + colorsCsv + ')',
                'linear-gradient(in oklch, to top, ' + colorsCsv + ')',
                'linear-gradient(to top in oklch, ' + colorsCsv + ')'
            ];
            for (const g of cands) {
                if (supportsBgImage(g)) return g;
            }
            // Kein CSS-OKLCH: Versuche JS-Fallback mit OKLCH-Interpolation -> sRGB-Mehrfachstops
            const csv = buildPerceptualGradientCsv(colorsCsv, 9);
            if (csv) return 'linear-gradient(to top, ' + csv + ')';
            // Fallback sRGB einfach
            return 'linear-gradient(to top,' + colorsCsv + ')';
        }

        let bars = document.getElementById("bars");
        for(let i = 0; i < 96; i++) { // 24h * 4 Balken (Initial)
            let bar = document.createElement('div');
            bar.id = 'bar_' + i;
            // Innerer Füllbalken für positive/negative Anzeige
            let inner = document.createElement('div');
            inner.className = 'bar-inner';
            bar.appendChild(inner);
            // Level-Indikator an der Nulllinie
            let marker = document.createElement('div');
            marker.className = 'level-marker';
            bar.appendChild(marker);
            bars.appendChild(bar);
        }
        let hours = document.getElementById("hours");
        for(let i = 0; i < 24; i++) { // 24 Stundenlabels
            let hour = document.createElement('div');
            hour.id = 'hour_' + i;
            hour.innerHTML = i;
            hour.className = i;
            hours.appendChild(hour);
        }

        function handleMessage(message) {
            
              
         /*   for(let i = 0; i < 48; i++) {
                //document.getElementById('hour_' + i).className = "";
                document.getElementById('hour_' + i).className = i;
            }
  */
            let min_price = Number.MAX_VALUE;
            let max_price = Number.MIN_VALUE;
            let avg_price = 0;
            
            let hours = document.getElementById("hours");
            
            const currentHour = new Date().getHours();
            const data = JSON.parse(message);

            // Pre-process suffix toggle so KPIs render correctly in this pass
            if (Object.prototype.hasOwnProperty.call(data, 'bar_price_vis_ct')) {
                ShowCtSuffix = !!data['bar_price_vis_ct'];
                VisCent = ShowCtSuffix ? ' ct\u00A0\u00A0' : '\u00A0\u00A0';
            }

            // Pre-process Scale so dataset rendering uses the current value even if order differs
            if (Object.prototype.hasOwnProperty.call(data, 'Scale')) {
                const sc = Number(data['Scale']);
                Scale = (isFinite(sc) && sc >= 0) ? sc : 0;
                try { console.debug('[Tibber] Scale received:', Scale); } catch(e) {}
            }

            for (const parameter in data) {
            
            const element = document.getElementById(parameter);
            var root = document.documentElement;

                // Abhängig vom Parameter werden allerdings verschiedene Werte angepasst
                switch (parameter) {
                    case 'price_cur':
                        if (element) element.innerHTML = data[parameter] + (ShowCtSuffix ? '&nbsp;ct' : '');
                    break;
                    case 'act_price':
                        // Bevorzugter aktueller Preis aus Backend-Variable
                        try {
                            let v = (typeof data[parameter] === 'number') ? data[parameter] : parseFloat(data[parameter]);
                            if (isFinite(v)) {
                                LastActPrice = v;
                                const elCur = document.getElementById('price_cur');
                                if (elCur) {
                                    const round = (typeof BarPriceRound === 'number' ? BarPriceRound : 2);
                                    elCur.innerHTML = v.toFixed(round) + (ShowCtSuffix ? '&nbsp;ct' : '');
                                }
                            }
                        } catch(e) { /* ignore */ }
                    break;
                    case 'price_min':
                        if (element) element.innerHTML = data[parameter] + (ShowCtSuffix ? '&nbsp;ct' : '');
                    break;
                    case 'price_max':
                        if (element) element.innerHTML = data[parameter] + (ShowCtSuffix ? '&nbsp;ct' : '');
                    break;
                    case 'price_avg':
                        if (element) element.innerHTML = data[parameter] + (ShowCtSuffix ? '&nbsp;ct' : '');
                    break;
                    case 'bar_price_round':
                        BarPriceRound = data[parameter];
                    break;
                    case 'bar_price_vis_ct':
                        // toggle for showing 'ct' suffix
                        ShowCtSuffix = !!data[parameter];
                        VisCent = ShowCtSuffix ? ' ct&nbsp;&nbsp;' : '&nbsp;&nbsp;';
                        // Also update overlay labels
                        window.requestAnimationFrame(rebuildOverlay);
                    break;
                    case 'bar_show_prices':
                        BarShowPrices = !!data[parameter];
                        // Overlay neu berechnen
                        window.requestAnimationFrame(rebuildOverlay);
                    break;
                    case 'show_grid':
                        ShowGrid = !!data[parameter];
                        // Overlay neu berechnen
                        window.requestAnimationFrame(rebuildOverlay);
                    break;
                    case 'GradientOptimization':
                    case 'ColorGradientOptimization':
                    case 'HTML_ColorGradientOptimization':
                        OptimizeGradient = !!data[parameter];
                        // Neu anwenden: aktuelle oder Default-CSV erneut setzen
                        try {
                            const colorsCsv = LastGradientCsv || DefaultGradientCsv;
                            const g = OptimizeGradient ? buildGradientToTop(colorsCsv) : ('linear-gradient(to top,' + colorsCsv + ')');
                            root.style.setProperty('--Gradient', g);
                        } catch(e) { /* ignore */ }
                        try {
                            const colorsCsvCur = LastGradientCurrentCsv || DefaultGradientCurrentCsv;
                            const g2 = OptimizeGradient ? buildGradientToTop(colorsCsvCur) : ('linear-gradient(to top,' + colorsCsvCur + ')');
                            root.style.setProperty('--GradientCurrent', g2);
                        } catch(e) { /* ignore */ }
                        try { repositionGradients(); } catch(e) { /* ignore */ }
                    break;
                    case 'GradientScaleByLevel':
                    case 'ScaleGradientByLevel':
                    case 'HTML_GradientScaleByLevel':
                        ScaleGradientByLevel = !!data[parameter];
                        // sofort aktualisieren
                        try {
                            if (!ScaleGradientByLevel) {
                                root.style.setProperty('--GradientScale', '1');
                            } else {
                                // Rechne die Skalierung anhand des aktuell sichtbaren höchsten Preislevels neu
                                const dataset = Array.isArray(lastDataset) ? lastDataset : [];
                                const hoursN = (typeof lastHoursToShow === 'number' && lastHoursToShow > 0) ? lastHoursToShow : 24;
                                const bph    = (typeof lastBarsPerHour === 'number' && lastBarsPerHour > 0) ? lastBarsPerHour : 4;
                                const expectedBars = Math.min(dataset.length, hoursN * bph);
                                const levelRank = (lvl) => {
                                    switch (lvl) {
                                        case 'VERY_CHEAP': return 0;
                                        case 'CHEAP': return 1;
                                        case 'NORMAL': return 2;
                                        case 'EXPENSIVE': return 3;
                                        case 'VERY_EXPENSIVE': return 4;
                                        default: return -1;
                                    }
                                };
                                let maxLevelRankVisible = -1;
                                for (let i = 0; i < expectedBars; i++) {
                                    const row = dataset[i];
                                    if (!row) continue;
                                    const pNum = (row && typeof row.price === 'number') ? row.price : NaN;
                                    const hasLevel = !!(row && typeof row.level === 'string' && row.level !== '');
                                    const baseNoData = !isFinite(pNum) || (row && row.nodata === true);
                                    const noPrice = baseNoData || (pNum === 0 && !hasLevel);
                                    if (noPrice) continue;
                                    const r = levelRank(row.level);
                                    if (r > maxLevelRankVisible) maxLevelRankVisible = r;
                                }
                                let visibleFraction = 1.0;
                                if (maxLevelRankVisible >= 0) {
                                    visibleFraction = 0.1 + (maxLevelRankVisible / 4) * 0.9;
                                }
                                const gradientScale = 1 / Math.max(0.1, Math.min(1.0, visibleFraction));
                                root.style.setProperty('--GradientScale', String(gradientScale));
                            }
                        } catch(e) { /* ignore */ }
                        try { repositionGradients(); } catch(e) { /* ignore */ }
                    break;
                    case 'only_price_bars':
                        OnlyPriceBars = !!data[parameter];
                        // Sichtbarkeit bereits gerenderter Balken umschalten
                        try {
                            for (let i = 0; i < lastTotalBars; i++) {
                                const el = document.getElementById('bar_' + i);
                                if (!el) continue;
                                const nd = el.getAttribute('data-nodata');
                                const attr = el.getAttribute('data-price');
                                const val = parseFloat(attr);
                                const hasPrice = isFinite(val) && nd !== '1';
                                el.style.display = (OnlyPriceBars && !hasPrice) ? 'none' : '';
                            }
                            // Stunden ein-/ausblenden anhand vorhandener Daten
                            for (let h = 0; h < lastHoursToShow; h++) {
                                const hourEl = document.getElementById('hour_' + h);
                                if (!hourEl) continue;
                                const hasData = !!lastHourHasData[h];
                                hourEl.style.display = (OnlyPriceBars && !hasData) ? 'none' : '';
                            }
                        } catch(e) { /* ignore */ }
                        window.requestAnimationFrame(rebuildOverlay);
                    break;
                    case 'FontSizeBars':
                       root.style.setProperty('--FontSizeBars', 'clamp('+data[parameter]+')');
                    break;
                    case 'FontSizeHours':
                       root.style.setProperty('--FontSizeHours', 'clamp('+data[parameter]+')');
                       // derive --HoursPad as 25% of each clamp bound to avoid calc()*clamp() issues
                       try {
                           const parts = String(data[parameter]).split(',');
                           const quarter = (s) => {
                               const m = String(s).trim().match(/^(-?\d+(?:\.\d+)?)([a-z%]+)$/i);
                               if (!m) return String(s).trim();
                               const v = parseFloat(m[1]) * 0.25;
                               const u = m[2];
                               return v + u;
                           };
                           if (parts.length === 3) {
                               const padClamp = 'clamp(' + quarter(parts[0]) + ', ' + quarter(parts[1]) + ', ' + quarter(parts[2]) + ')';
                               root.style.setProperty('--HoursPad', padClamp);
                           }
                       } catch(e) { /* ignore */ }
                       // re-measure and auto-fit hours row
                       window.requestAnimationFrame(() => { try { autoFitHoursFont(); } catch(e) {} try { measureHoursHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} });
                    break;
                    case 'FontSizePrices':
                       root.style.setProperty('--FontSizePrices', 'clamp('+data[parameter]+')');
                       // prices row height depends on its font size; re-measure and rebuild overlay
                       window.requestAnimationFrame(() => { try { measurePricesHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} try { repositionGradients(); } catch(e) {} });
                    break;
                    case 'FontSizeScale':
                       // separate scale (grid price labels) font size
                       root.style.setProperty('--FontSizeScale', 'clamp('+data[parameter]+')');
                       window.requestAnimationFrame(rebuildOverlay);
                    break;
                    case 'FCBars':
                        root.style.setProperty('--FCBars', '#'+data[parameter]);
                        BarColor = '#'+data[parameter];
                    break;  
                    case 'FCHour':
                        root.style.setProperty('--FCHour', '#'+data[parameter]);
                        UseCurrentColorHour = '#'+data[parameter];

                    break;
                    case 'BGCHour':
                        root.style.setProperty('--BGCHour', '#'+data[parameter]);
                    break;
                    case 'FCHourDefault':
                        if (data[parameter]){
                            document.documentElement.style.setProperty('--content-color', '#'+data[parameter] );
                            console.log("Use fontcolors: #" +data[parameter]);
                        }
                    break;
                    case 'BorderRadius':
                        // übernehme den eingestellten Balkenradius (px)
                        {
                            let val = data[parameter];
                            if (typeof val !== 'number') { val = parseFloat(val); }
                            if (isFinite(val)) {
                                root.style.setProperty('--BorderRadius', val + 'px');
                            }
                        }
                    break;
                    case 'Scale':
                        Scale =  data[parameter];
                    break;
                    case 'hour_write_mode':
                        root.style.setProperty('--WriteMode','horizontal-tb');
                        root.style.setProperty('--TextAlignHours','center');
                       if(data[parameter] == true )
                            {
                                root.style.setProperty('--WriteMode','vertical-lr');
                                root.style.setProperty('--TextAlignHours','left');
                            }
                        // writing mode changes intrinsic height; auto-fit and re-measure to update --HoursH and overlay
                        window.requestAnimationFrame(() => { try { autoFitHoursFont(); } catch(e) {} try { measureHoursHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} });
                        break;
                    case 'NoData':
                            if(Object.keys(data[parameter]).length >=1 )
                            {
                                document.getElementById('block').innerHTML = data[parameter];
                                document.getElementById('block').style.color = "red";
                                console.log('NoData');
                            }
                    break; 
                    case 'Gradient':
                        try {
                            const colorsCsv = String(data[parameter] || '');
                            LastGradientCsv = colorsCsv;
                            const g = OptimizeGradient ? buildGradientToTop(colorsCsv) : ('linear-gradient(to top,' + colorsCsv + ')');
                            root.style.setProperty('--Gradient', g);
                            BarGradient = g;
                            console.log(g);
                        } catch(e) {
                            root.style.setProperty('--Gradient', 'linear-gradient(to top,'+data[parameter]+')');
                        }
                    break;
                    case 'GradientCurrent':
                        try {
                            const colorsCsv = String(data[parameter] || '');
                            LastGradientCurrentCsv = colorsCsv;
                            const g2 = OptimizeGradient ? buildGradientToTop(colorsCsv) : ('linear-gradient(to top,' + colorsCsv + ')');
                            root.style.setProperty('--GradientCurrent', g2);
                        } catch(e) {
                            root.style.setProperty('--GradientCurrent', 'linear-gradient(to top,'+data[parameter]+')');
                        }
                    break;
                    case 'MarkPriceLevel':
                        MarkPriceLevel = data[parameter];
                    break;
                    case 'BGCPriceVC':
                        BGCPriceVC = data[parameter];
                    break; 
                    case 'BGCPriceC':
                        BGCPriceC = data[parameter];
                    break; 
                    case 'BGCPriceN':
                        BGCPriceN = data[parameter];
                    break; 
                    case 'BGCPriceE':
                        BGCPriceE = data[parameter];
                    break; 
                    case 'BGCPriceVE':
                        BGCPriceVE = data[parameter];
                    break; 
                    case 'PriceLevelThickness':
                        PriceLevelThickness = data[parameter];
                    break;
                    case 'HourAhead':
                        HourAhead = data[parameter];
                        try {
                            const hoursN = Math.max(1, parseInt(HourAhead, 10) || 1);
                            const BPH    = Math.max(1, parseInt(BarsPerHour, 10) || 1);
                            // Per-Hour flex basis (labels): (100% - 2px*hours) / hours
                            root.style.setProperty('--HourAhead',  '0 0 calc((100% - ('+(hoursN*2)+'px)) / '+hoursN+')');
                            // Per-Bar flex basis: (Stundenbreite - 2px Margins) / BarsPerHour
                            root.style.setProperty('--CountBars', '0 0 calc((((100% - ('+(hoursN*2)+'px)) / '+hoursN+') - 2px) / '+BPH+')');
                        } catch(e) { /* ignore */ }
                        window.requestAnimationFrame(() => { try { autoFitHoursFont(); } catch(e) {} try { measureHoursHeight(); } catch(e) {} try { measurePricesHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} try { repositionGradients(); } catch(e) {} });
                    break; 
                                        
                    case 'Ahead_Price_Data':
                       // Datensatz übernehmen und Granularität erkennen (1h oder 15min)
                       const dataset = data[parameter];
                       // Für spätere Layout-basierte Neupositionierung cachen
                       try { lastDataset = Array.isArray(dataset) ? dataset.slice() : []; } catch(e) { lastDataset = []; }
                       // Granularität erkennen
                       try {
                           let detected = BarsPerHour;
                           if (Array.isArray(dataset) && dataset.length >= 2) {
                               let dt = 0;
                               if (dataset[0] && typeof dataset[0].start === 'number' && typeof dataset[0].end === 'number') {
                                   dt = dataset[0].end - dataset[0].start;
                               } else if (dataset[1] && typeof dataset[1].start === 'number' && typeof dataset[0].start === 'number') {
                                   dt = dataset[1].start - dataset[0].start;
                               }
                               if (dt >= 3599 && dt <= 3601) {
                                   detected = 1;
                               } else if (dt >= 899 && dt <= 901) {
                                   detected = 4;
                               } else if (dt > 0) {
                                   // Fallback: runde auf nächstliegende bekannte Granularität
                                   detected = (dt <= 1200) ? 4 : 1;
                               }
                           } else if (Array.isArray(dataset) && dataset.length > 0) {
                               // Nur ein Punkt: anhand von Heuristik -> stundenweise annehmen
                               detected = 1;
                           }
                           BarsPerHour = detected;
                       } catch(e) { /* ignore */ }
                       // min/max für relative Höhe ermitteln (Balken ohne echte Preisdaten ignorieren)
                       let localMin = Number.POSITIVE_INFINITY;
                       let localMax = Number.NEGATIVE_INFINITY;
                       for (let row of dataset) {
                           const p = (row && typeof row.price === 'number') ? row.price : NaN;
                           const nd = !!(row && row.nodata === true);
                           const hasLevel = !!(row && typeof row.level === 'string' && row.level !== '');
                           // Nur tatsächliche Preisdaten: numerisch, nicht nodata und keine Platzhalter-Null (0 + leeres Level)
                           if (!isFinite(p) || nd || (p === 0 && !hasLevel)) continue;
                           if (p < localMin) localMin = p;
                           if (p > localMax) localMax = p;
                       }
                       if (!isFinite(localMin) || !isFinite(localMax)) { localMin = 0; localMax = 0.0001; }
                       if (localMax === localMin) { localMax = localMin + 0.0001; }

                       // Neue Semantik: HTML_Scale = n => n*10% Cropping des Bereichs [0 ct .. localMin]
                       // f in [0..1]
                       const eps = 0.0001;
                       const scVal = Number(Scale) || 0;
                       const f = Math.max(0, Math.min(1, scVal * 0.1));
                       let viewMin;
                       if (localMin >= 0 && localMax > 0) {
                           // Positive-only: Scale=0 deaktiviert Cropping -> beginne bei 0 (kein Wegschneiden)
                           if (scVal <= 0) {
                               viewMin = 0;
                           } else {
                               // Sichtbereich beginnt bei Anteil von 0..localMin
                               viewMin = Math.min(localMax - eps, f * localMin);
                           }
                       } else {
                           // Negative oder gemischte Preise: Cropping deaktiviert
                           viewMin = localMin;
                       }
                       let viewMax = localMax;           // sichtbarer Höchstpreis
                       if (!isFinite(viewMin)) viewMin = localMin;
                       if (!isFinite(viewMax)) viewMax = localMax;
                       // Sicherstellen, dass die Range > 0 bleibt
                       if (viewMin >= viewMax) {
                           viewMin = viewMax - eps;
                       }

                       // Baseline (Nulllinie) berechnen: Position von oben in Prozent auf Basis des sichtbaren Fensters
                       let baselineTopPct = 100; // Standard: alles positiv -> Nulllinie unten
                       if (viewMin < 0 && viewMax > 0) {
                           baselineTopPct = (viewMax / (viewMax - viewMin)) * 100;
                       } else if (viewMax <= 0) {
                           baselineTopPct = 0; // alles negativ -> Nulllinie oben
                       } else {
                           baselineTopPct = 100; // alles positiv -> Nulllinie unten
                       }
                       const baselineBottomPct = 100 - baselineTopPct;

                       try { console.debug('[Tibber] viewMin/viewMax:', viewMin, viewMax, 'baselineTopPct:', baselineTopPct, 'cropPercent:', f, 'cropDisabledDueToNegative:', (localMin < 0), 'cropDisabledDueToScaleZero:', (scVal <= 0)); } catch(e) {}

                       // Baseline zeichnen/aktualisieren
                       let baseline = document.getElementById('baseline');
                       if (!baseline) {
                           baseline = document.createElement('div');
                           baseline.id = 'baseline';
                           bars.appendChild(baseline);
                       }
                       const clampedTop = Math.max(0, Math.min(99.5, baselineTopPct));
                       baseline.style.top = clampedTop + '%';
                       // Baseline im Raster nicht anzeigen
                       baseline.style.display = 'none';

                       // Für Balkenberechnung: Baseline streng auf [0..100] klemmen
                       const baseTopLocal = Math.max(0, Math.min(100, baselineTopPct));
                       const baseBottomLocal = 100 - baseTopLocal;

                       let CurrentHourIndex = 0;
                       // Sicherstellen, dass 24 Stunden angezeigt werden, falls HourAhead
                       // noch nicht gesetzt wurde
                       let hoursToShow = (typeof HourAhead === 'number' && HourAhead > 0)
                           ? HourAhead
                           : 24;
                       if (hoursToShow > 48) hoursToShow = 48;
                       const expectedBars = hoursToShow * BarsPerHour;
                       // Höhe des Balken-Containers messen und als CSS-Variable setzen,
                       // damit der Farbverlauf in allen Balken identisch skaliert wird
                       let barsHeightPx = 0;
                       try {
                           const barsRect = bars.getBoundingClientRect();
                           barsHeightPx = Math.ceil(barsRect.height || 0);
                           if (barsHeightPx > 0) { root.style.setProperty('--BarsHeightPx', barsHeightPx + 'px'); }
                       } catch(e) { /* ignore */ }
                       // Prozent-Mapping über die gesamte sichtbare Range
                       const fullRange = (viewMax - viewMin) || 1;
                       function yPctFor(val) {
                           let t = (val - viewMin) / fullRange; // 0..1
                           if (!isFinite(t)) t = 0;
                           t = Math.max(0, Math.min(1, t));
                           return 100 * (1 - t); // 0% = oben, 100% = unten
                       }
                       
                       // Gradienten-Skalierung basierend auf höchstem sichtbaren Preislevel (per Toggle)
                       try {
                           if (ScaleGradientByLevel) {
                               const levelRank = (lvl) => {
                                   switch (lvl) {
                                       case 'VERY_CHEAP': return 0;
                                       case 'CHEAP': return 1;
                                       case 'NORMAL': return 2;
                                       case 'EXPENSIVE': return 3;
                                       case 'VERY_EXPENSIVE': return 4;
                                       default: return -1;
                                   }
                               };
                               let maxLevelRankVisible = -1;
                               for (let i = 0; i < expectedBars; i++) {
                                   const row = dataset[i];
                                   if (!row) continue;
                                   const pNum = (row && typeof row.price === 'number') ? row.price : NaN;
                                   const hasLevel = !!(row && typeof row.level === 'string' && row.level !== '');
                                   const baseNoData = !isFinite(pNum) || (row && row.nodata === true);
                                   const noPrice = baseNoData || (pNum === 0 && !hasLevel);
                                   if (noPrice) continue;
                                   const r = levelRank(row.level);
                                   if (r > maxLevelRankVisible) maxLevelRankVisible = r;
                               }
                               let visibleFraction = 1.0; // Anteil des Verlaufs, der innerhalb des Balkens sichtbar sein soll
                               if (maxLevelRankVisible >= 0) {
                                   // Linear von 10% (VERY_CHEAP) bis 100% (VERY_EXPENSIVE)
                                   visibleFraction = 0.1 + (maxLevelRankVisible / 4) * 0.9;
                               }
                               const gradientScale = 1 / Math.max(0.1, Math.min(1.0, visibleFraction));
                               root.style.setProperty('--GradientScale', String(gradientScale));
                           } else {
                               root.style.setProperty('--GradientScale', '1');
                           }
                       } catch(e) { /* ignore */ }
                       

                       // pro Stunde prüfen, ob mindestens ein gültiger Preis vorhanden ist
                       lastHourHasData = new Array(hoursToShow).fill(false);
                       for (let h = 0; h < hoursToShow; h++) {
                           for (let q = 0; q < BarsPerHour; q++) {
                               const idx = h * BarsPerHour + q;
                               if (idx < dataset.length) {
                                   const r = dataset[idx];
                                   const p = (r && typeof r.price === 'number') ? r.price : NaN;
                                   const nd = !!(r && r.nodata === true);
                                   const hasLevel = !!(r && typeof r.level === 'string' && r.level !== '');
                                   // Echte Daten: numerisch, nicht nodata, keine Platzhalter-Null
                                   if (isFinite(p) && !nd && !(p === 0 && !hasLevel)) { lastHourHasData[h] = true; break; }
                               }
                           }
                       }

                       // Precompute erste/letzte sichtbare Balken pro Stunde für saubere Ränder
                       let visibleHoursCount = hoursToShow;
                       let firstVisIdxPerHour = new Array(hoursToShow).fill(-1);
                       let lastVisIdxPerHour  = new Array(hoursToShow).fill(-1);
                       if (OnlyPriceBars) {
                           visibleHoursCount = lastHourHasData.reduce((a,b)=>a + (b?1:0), 0);
                           if (!isFinite(visibleHoursCount) || visibleHoursCount <= 0) visibleHoursCount = hoursToShow;
                           for (let h = 0; h < hoursToShow; h++) {
                               if (!lastHourHasData[h]) continue;
                               for (let q = 0; q < BarsPerHour; q++) {
                                   const idx = h * BarsPerHour + q;
                                   if (idx < dataset.length) {
                                       const r = dataset[idx];
                                       const p = (r && typeof r.price === 'number') ? r.price : NaN;
                                       const nd = !!(r && r.nodata === true);
                                       const hasLevel = !!(r && typeof r.level === 'string' && r.level !== '');
                                       const noPrice = !isFinite(p) || nd || (p === 0 && !hasLevel);
                                       if (!noPrice) {
                                           if (firstVisIdxPerHour[h] === -1) firstVisIdxPerHour[h] = idx;
                                           lastVisIdxPerHour[h] = idx;
                                       }
                                   }
                               }
                           }
                       }

                       // Layout dynamisch anpassen: Stundenbreite (volle Breite auf sichtbare Stunden), Balkenbreite per CSS-Var bzw. inline
                       try {
                           const hoursN = Math.max(1, OnlyPriceBars ? (visibleHoursCount || hoursToShow) : hoursToShow);
                           const BPH    = Math.max(1, BarsPerHour || 1);
                           root.style.setProperty('--HourAhead',  '0 0 calc((100% - ('+(hoursN*2)+'px)) / '+hoursN+')');
                           // Bei aktivem Filter setzen wir pro Balken inline die Flex-Breite, daher bleibt --CountBars als Fallback bestehen
                           root.style.setProperty('--CountBars', '0 0 calc(((100% - ('+(hoursN*2)+'px)) / '+hoursN+') / '+BPH+')');
                       } catch(e) { /* ignore */ }

                       // Sicherstellen, dass genügend Stunden-Labels existieren
                       const hoursContainer = document.getElementById('hours');
                       for (let h = 0; h < hoursToShow; h++) {
                           let hEl = document.getElementById('hour_' + h);
                           if (!hEl) {
                               hEl = document.createElement('div');
                               hEl.id = 'hour_' + h;
                               hEl.className = '';
                               hoursContainer.appendChild(hEl);
                           }
                           hEl.style.display = '';
                           // Breite je Stunden-Label wird über CSS-Variable --HourAhead gesetzt
                       }
                       // Bei aktivem Filter Stunden ohne Preisinfo ausblenden
                       if (OnlyPriceBars) {
                           for (let h = 0; h < hoursToShow; h++) {
                               const hEl = document.getElementById('hour_' + h);
                               if (!hEl) continue;
                               hEl.style.display = lastHourHasData[h] ? '' : 'none';
                           }
                       }
                       // Nach dem Setzen aller Stunden-Labels: Schrift anpassen
                       try { window.requestAnimationFrame(() => { try { autoFitHoursFont(); } catch(e) {} try { measureHoursHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} }); } catch(e) { /* ignore */ }
                       // Nicht benötigte alte Labels ausblenden
                       for (let h = hoursToShow; h < 96; h++) {
                           const extra = document.getElementById('hour_' + h);
                           if (extra) extra.style.display = 'none';
                       }

                       // Startstunde ermitteln: aus Datensatz (erster Eintrag) oder aktuelle Stunde
                       let displayStartHour = (Array.isArray(dataset) && dataset.length > 0 && dataset[0] && typeof dataset[0].start === 'number')
                           ? (new Date(dataset[0].start * 1000)).getHours()
                           : (new Date()).getHours();
                       // Stunden-Labels für das gesamte Fenster setzen (mit Wrap um 24)
                       for (let h = 0; h < hoursToShow; h++) {
                           const hEl = document.getElementById('hour_' + h);
                           if (hEl) {
                               const lbl = (displayStartHour + h) % 24;
                               hEl.innerText = lbl;
                               // Reset Klasse/Farbe; Hervorhebung erfolgt später
                               hEl.className = '';
                               hEl.style.color = '';
                           }
                       }

                       // Stundenmittel vorberechnen (nur Balken mit Daten berücksichtigen)
                       const hourAverages = [];
                       for (let h = 0; h < hoursToShow; h++) {
                           let sum = 0, count = 0;
                           for (let q = 0; q < BarsPerHour; q++) {
                               const idx = h * BarsPerHour + q;
                               if (idx < dataset.length) {
                                   const r = dataset[idx];
                                   if (r && typeof r.price === 'number' && !(r.nodata === true)) {
                                       const hasLevel = !!(typeof r.level === 'string' && r.level !== '');
                                       if (!(r.price === 0 && !hasLevel)) { sum += r.price; count++; }
                                   }
                               }
                           }
                           hourAverages[h] = count > 0 ? (sum / count) : 0;
                       }

                       // Min/Max in der sichtbaren Menge verfolgen
                       let bestMaxVal = -Infinity, bestMinVal = Infinity;
                       let idxMax = -1, idxMin = -1;
                       // Aktuelle Zeit und Segment für Hervorhebung ermitteln
                       const now = new Date();
                       const nowEpochSec = Math.floor(now.getTime() / 1000);
                       const currentHourNow = now.getHours();
                       const currentMinuteNow = now.getMinutes();
                       // Capture the currently active segment's price for the "Aktuell" label
                       let currentDisplayPrice = null;
                       const segSize = Math.max(1, Math.floor(60 / BarsPerHour));
                       let currentSeg = Math.floor(currentMinuteNow / segSize);
                       if (currentSeg >= BarsPerHour) currentSeg = BarsPerHour - 1;
                       for (let i = 0; i < expectedBars; i++) {
                            const row = dataset[i] || { price: NaN, nodata: true };
                            const hourIndex = Math.floor(i / BarsPerHour);
                            const groupAvg = (hourAverages[hourIndex] || 0);

                            let barindex = document.getElementById('bar_' + i);
                            if (!barindex) {
                                barindex = document.createElement('div');
                                barindex.id = 'bar_' + i;
                                const inner = document.createElement('div');
                                inner.className = 'bar-inner';
                                barindex.appendChild(inner);
                                const marker = document.createElement('div');
                                marker.className = 'level-marker';
                                barindex.appendChild(marker);
                                bars.appendChild(barindex);
                            } else {
                                barindex.style.display = '';
                            }
                            // Breite je Balken wird über CSS-Variable --CountBars gesetzt
                            // Standardmäßig keine aktuelle-Stunde-Markierung
                            try { barindex.classList.remove('current-hour'); } catch(e) { /* ignore */ }
                            const hourindex = document.getElementById('hour_' + hourIndex);
                            // Nur die erste sichtbare Stunde (linke) hervorheben
                            if (hourindex) {
                                if (hourIndex === 0) {
                                    hourindex.className = "current";
                                    hourindex.style.color = UseCurrentColorHour;
                                } else {
                                    hourindex.className = "";
                                }
                            }

                            if (barindex) {
                                // Preis-/NoData-Status einmalig berechnen und für alle folgenden Schritte nutzen
                                const pNum = (typeof row.price === 'number') ? row.price : NaN;
                                const hasLevel = !!(row && typeof row.level === 'string' && row.level !== '');
                                const baseNoData = !isFinite(pNum) || (row && row.nodata === true) || (i >= dataset.length);
                                const noPrice = baseNoData || (pNum === 0 && !hasLevel);

                                const fill = barindex.firstElementChild || barindex.querySelector('.bar-inner');
                                if (fill) {
                                    let heightPct = 0;
                                    if (noPrice) {
                                        if (OnlyPriceBars) {
                                            // vollständig ausblenden, wenn keine Preisinfo vorhanden
                                            barindex.style.display = 'none';
                                            try { barindex.setAttribute('data-nodata', '1'); } catch(e) { /* ignore */ }
                                        } else {
                                            // Platzhalter: grauer Balken volle Höhe von unten
                                            heightPct = 100;
                                            fill.style.top = '';
                                            fill.style.bottom = '0';
                                            fill.style.height = '100%';
                                            fill.style.borderTopLeftRadius = 'var(--BorderRadius)';
                                            fill.style.borderTopRightRadius = 'var(--BorderRadius)';
                                            fill.style.borderBottomLeftRadius = 'var(--BorderRadius)';
                                            fill.style.borderBottomRightRadius = 'var(--BorderRadius)';
                                            fill.style.opacity = '1';
                                            try {
                                                const phCsv = 'rgba(128,128,128,0.3), rgba(128,128,128,0)';
                                                const phGrad = OptimizeGradient ? buildGradientToTop(phCsv) : ('linear-gradient(to top, ' + phCsv + ')');
                                                fill.style.backgroundImage = phGrad;
                                            } catch(e) {
                                                fill.style.backgroundImage = 'linear-gradient(to top, rgba(128,128,128,0.3), rgba(128,128,128,0))';
                                            }
                                            try { barindex.setAttribute('data-nodata', '1'); } catch(e) { /* ignore */ }
                                        }
                                    } else if (viewMin >= 0) {
                                        // Positiv-only Range: von [viewMin..viewMax] auf [0..100] am Boden
                                        const denom = (viewMax - viewMin) || 1;
                                        const frac = Math.max(0, Math.min(1, (pNum - viewMin) / denom));
                                        heightPct = frac * 100;
                                        fill.style.top = '';
                                        fill.style.bottom = '0';
                                        fill.style.height = Math.max(0, Math.min(100, heightPct)) + '%';
                                        // Gradient immer am unteren Rand verankern, damit nur der untere Anteil sichtbar bleibt
                                        try { fill.style.backgroundPosition = 'left bottom'; } catch(e) { /* ignore */ }
                                        fill.style.borderTopLeftRadius = 'var(--BorderRadius)';
                                        fill.style.borderTopRightRadius = 'var(--BorderRadius)';
                                        fill.style.borderBottomLeftRadius = '0px';
                                        fill.style.borderBottomRightRadius = '0px';
                                        fill.style.opacity = '1';
                                        fill.style.backgroundImage = '';
                                        try { barindex.removeAttribute('data-nodata'); } catch(e) { /* ignore */ }
                                    } else {
                                        // Gemischt/negativ: Höhen über globales Mapping bestimmen
                                        const y0 = baseTopLocal;          // Baseline in % von oben
                                        const yP = yPctFor(pNum);
                                        if (pNum >= 0) {
                                            // oberhalb der Baseline
                                            heightPct = Math.max(0, y0 - yP);
                                            fill.style.top = '';
                                            fill.style.bottom = (100 - y0) + '%';
                                            // Gradient an Container ausrichten: Top = (y0 - heightPct)%
                                            try {
                                                const topPct = Math.max(0, y0 - heightPct);
                                                const bgPosY = - (barsHeightPx * topPct / 100);
                                                fill.style.backgroundPosition = '0px ' + bgPosY + 'px';
                                            } catch(e) { /* ignore */ }
                                        } else {
                                            // unterhalb der Baseline
                                            heightPct = Math.max(0, yP - y0);
                                            fill.style.top = y0 + '%';
                                            fill.style.bottom = '';
                                            // Gradient an Container ausrichten: Top = y0%
                                            try {
                                                const bgPosY = - (barsHeightPx * y0 / 100);
                                                fill.style.backgroundPosition = '0px ' + bgPosY + 'px';
                                            } catch(e) { /* ignore */ }
                                        }
                                        fill.style.height = Math.max(0, Math.min(100, heightPct)) + '%';
                                        fill.style.borderTopLeftRadius = (pNum >= 0) ? 'var(--BorderRadius)' : '0px';
                                        fill.style.borderTopRightRadius = (pNum >= 0) ? 'var(--BorderRadius)' : '0px';
                                        fill.style.borderBottomLeftRadius = (pNum < 0) ? 'var(--BorderRadius)' : '0px';
                                        fill.style.borderBottomRightRadius = (pNum < 0) ? 'var(--BorderRadius)' : '0px';
                                        fill.style.opacity = '1';
                                        fill.style.backgroundImage = '';
                                        try { barindex.removeAttribute('data-nodata'); } catch(e) { /* ignore */ }
                                    }
                                }

                                // Sichtbaren Min/Max-Index aktualisieren (nur echte Daten berücksichtigen)
                                const pVal = pNum;
                                if (!noPrice && isFinite(pVal)) {
                                    if (pVal > bestMaxVal) { bestMaxVal = pVal; idxMax = i; }
                                    if (pVal < bestMinVal) { bestMinVal = pVal; idxMin = i; }
                                }
                                // Preis als Attribut für evtl. spätere Auswertungen ablegen
                                try { barindex.setAttribute('data-price', isFinite(pVal) ? String(pVal) : ''); } catch(e) { /* ignore */ }

                                // Keine Texte in 15-Minuten-Balken
                                // Abstände und Flex: bei aktivem Filter dynamisch pro Stunde, sonst Standard nach q
                                const q = i % BarsPerHour; // 0..3
                                // 15-Minuten: jeden zweiten Balken minimal dunkler überlagern (10% Schwarz)
                                try {
                                    if (BarsPerHour >= 4 && !noPrice) {
                                        if ((q % 2) === 1) { fill.classList.add('shaded'); }
                                        else { fill.classList.remove('shaded'); }
                                    } else {
                                        fill.classList.remove('shaded');
                                    }
                                } catch(e) { /* ignore */ }
                                if (OnlyPriceBars) {
                                    // Nur Ränder an erstem/letztem sichtbaren Balken setzen, Breite über Standard lassen
                                    barindex.style.marginLeft = '0px';
                                    barindex.style.marginRight = '0px';
                                    if (!noPrice) {
                                        if (i === firstVisIdxPerHour[hourIndex]) barindex.style.marginLeft = '1px';
                                        if (i === lastVisIdxPerHour[hourIndex])  barindex.style.marginRight = '1px';
                                    }
                                    barindex.style.flex = '';
                                } else {
                                    // Standardbreiten über CSS-Var --CountBars; fester Abstand am Stundenrand
                                    if (q === 0) {
                                        barindex.style.marginLeft = '1px';
                                    } else {
                                        barindex.style.marginLeft = '0px';
                                    }
                                    if (q === BarsPerHour - 1) {
                                        barindex.style.marginRight = '1px';
                                    } else {
                                        barindex.style.marginRight = '0px';
                                    }
                                    barindex.style.flex = '';
                                }

                                // Exakt den aktuellen Balken hervorheben
                                try {
                                    let isCurrent = false;
                                    const s = (row && typeof row.start === 'number') ? row.start : NaN;
                                    const e = (row && typeof row.end === 'number') ? row.end : NaN;
                                    if (isFinite(s) && isFinite(e)) {
                                        // Zeitfensterbasiert (präzise bei 15-min Daten)
                                        isCurrent = nowEpochSec >= s && nowEpochSec < e;
                                    } else {
                                        // Fallback: Anzeige-Stunde ableiten und mit aktuellem Segment vergleichen
                                        try {
                                            const displayHour = ((displayStartHour || 0) + hourIndex) % 24;
                                            isCurrent = (displayHour === currentHourNow && q === currentSeg);
                                        } catch(e) { isCurrent = false; }
                                    }
                                    if (isCurrent) {
                                        barindex.classList.add('current-hour');
                                    }
                                } catch(e) { /* ignore */ }

                                // Preislevel-Indikator immer auf Nulllinie zeichnen
                                const marker = barindex.querySelector('.level-marker');
                                if (marker) {
                                    if (typeof MarkPriceLevel !== 'undefined' && MarkPriceLevel && row.level) {
                                        let color = '';
                                        switch (row.level){
                                            case 'NORMAL': color = BGCPriceN; break;
        										case 'CHEAP': color = BGCPriceC; break;
        										case 'VERY_CHEAP': color = BGCPriceVC; break;
        										case 'EXPENSIVE': color = BGCPriceE; break;
        										case 'VERY_EXPENSIVE': color = BGCPriceVE; break;
                                            default: color = '';
                                        }
                                        marker.style.top = clampedTop + '%';
                                        marker.style.borderTop = color ? (PriceLevelThickness+'px solid '+color) : 'none';
                                        marker.style.display = '';
                                    } else {
                                        marker.style.borderTop = 'none';
                                        marker.style.display = 'none';
                                    }
                                }
                            }
                       }

                       // Indizes für Min-/Max-Balken für Overlay-Linien cachen
                       lastIndexMaxBar = idxMax;
                       lastIndexMinBar = idxMin;
                       // Update the "Aktuell" KPI preferring act_price (LastActPrice),
                       // then the current segment, then fallback to the hourly average of the first visible hour
                       try {
                           const elCur = document.getElementById('price_cur');
                           if (elCur) {
                               let v = (typeof LastActPrice === 'number' && isFinite(LastActPrice)) ? LastActPrice : null;
                               if (v === null) {
                                   v = (typeof currentDisplayPrice === 'number' && isFinite(currentDisplayPrice)) ? currentDisplayPrice : null;
                               }
                               if (v === null) {
                                   const hv = Array.isArray(hourAverages) ? hourAverages[0] : null;
                                   if (typeof hv === 'number' && isFinite(hv)) v = hv;
                               }
                               if (typeof v !== 'number' || !isFinite(v)) v = 0;
                               elCur.innerHTML = v.toFixed(BarPriceRound) + (ShowCtSuffix ? '&nbsp;ct' : '');
                           }
                       } catch(e) { /* ignore */ }

                       // Fallback: Falls kein Balken per Zeitfenster markiert wurde, markiere den erwarteten aktuellen Index
                       try {
                           const targetHourIndex = 0; // erste sichtbare Stunde ist die aktuelle
                           const segSize2 = Math.max(1, Math.floor(60 / BarsPerHour));
                           let currentSeg2 = Math.floor((new Date()).getMinutes() / segSize2);
                           if (currentSeg2 >= BarsPerHour) currentSeg2 = BarsPerHour - 1;
                           const targetIdx = targetHourIndex * BarsPerHour + currentSeg2;
                           if (targetIdx >= 0 && targetIdx < expectedBars) {
                               const tEl = document.getElementById('bar_' + targetIdx);
                               if (tEl) tEl.classList.add('current-hour');
                           }
                       } catch(e) { /* ignore */ }

                       // Überzählige Bars/Hours ausblenden
                       for (let i = expectedBars; i < lastTotalBars; i++) {
                           const extraBar = document.getElementById('bar_' + i);
                           if (extraBar) extraBar.style.display = 'none';
                       }
                       for (let i = hoursToShow; i < lastTotalHours; i++) {
                           const extraHour = document.getElementById('hour_' + i);
                           if (extraHour) extraHour.style.display = 'none';
                       }
                       // Cache aktualisieren und Overlay nach Layout berechnen
                       lastHoursToShow = hoursToShow;
                       lastHourAverages = hourAverages.slice();
                       lastBarsPerHour = BarsPerHour;
                       // Für Mapping die Baseline für 0 berechnen (nur informativ) und sichtbare Range cachen
                       lastBaselineTopPct = baselineTopPct;
                       lastLocalMin = viewMin;
                       lastLocalMax = viewMax;
                       lastTotalBars = Math.max(lastTotalBars, expectedBars);
                       lastTotalHours = Math.max(lastTotalHours, hoursToShow);
                       // Stundenhöhe nach Text messen und anwenden, danach Overlay neu zeichnen
                       window.requestAnimationFrame(() => { try { measureHoursHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} });
                           
                        break;
                        case 'reload':
                            location.reload();
                            console.log('location reload: ', parameter);

                        break;
                        default:
                            console.log('Unknown parameter: ', parameter);
                        
                } // end switch
            } // end for-in

     }
            // Nach Definition: evtl. gepufferte Nachrichten abarbeiten
            try {
                const queued = window._pendingMessages || [];
                window._pendingMessages = [];
                for (const m of queued) { handleMessage(m); }
                // Nach dem Abarbeiten und erstem Layout sicherstellen, dass der Verlauf korrekt verankert ist
                window.requestAnimationFrame(() => { try { measureHoursHeight(); } catch(e) {} try { measurePricesHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} try { repositionGradients(); } catch(e) {} });
            } catch(e) { /* ignore */ }
            
        // Demo-Modus: bei ?demo=1 oder ?demo=true 24h×4 Testdaten erzeugen
        try {
            const qp = new URLSearchParams(window.location.search || '');
            const demo = qp.get('demo');
            if (demo === '1' || demo === 'true') {
                const BarsPerHour = 4;
                const hoursToShow = 24;
                const now = new Date();
                now.setMinutes(0, 0, 0);
                const startEpochHour = Math.floor(now.getTime() / 1000);

                const dataset = [];
                const base = 5.0;    // Basispreis ct/kWh (deutlich niedriger für negative Phasen)
                const swing = 20.0;  // Größere Amplitude für starke Negativwerte
                const noiseAmp = 3.0;
                for (let h = 0; h < hoursToShow; h++) {
                    for (let q = 0; q < BarsPerHour; q++) {
                        const start = startEpochHour + (h * 3600) + (q * 900);
                        const end   = start + 900;
                        const priceRaw = base + Math.sin((h/24) * Math.PI * 2) * swing + (Math.random() - 0.5) * noiseAmp;
                        const price = Number(priceRaw.toFixed(3)); // negative erlaubt
                        const level = price < 18 ? 'VERY_CHEAP'
                                      : price < 20 ? 'CHEAP'
                                      : price < 22 ? 'NORMAL'
                                      : price < 24 ? 'EXPENSIVE'
                                      : 'VERY_EXPENSIVE';
                        dataset.push({ start, end, price, level });
                    }
                }

                const msg = {
                    HourAhead: hoursToShow,
                    Ahead_Price_Data: dataset,
                    bar_price_round: 2,
                    bar_price_vis_ct: true,
                    Scale: 1,
                    Gradient: '#28cdab, #1d8b75',
                    FCBars: 'FFFFFF',
                    FCHour: 'FFFFFF',
                    MarkPriceLevel: true,
                    BGCPriceVC: '#28CDAB',
                    BGCPriceC:  '#008000',
                    BGCPriceN:  '#28CDAB',
                    BGCPriceE:  '#FF8000',
                    BGCPriceVE: '#FF0000',
                    PriceLevelThickness: 2
                };
                const payload = JSON.stringify(msg);
                if (typeof handleMessage === 'function') {
                    handleMessage(payload);
                } else {
                    // Fallback: verzögerter Aufruf, falls Parsereihenfolge verzögert
                    setTimeout(() => {
                        if (typeof handleMessage === 'function') {
                            handleMessage(payload);
                        }
                    }, 0);
                }
            }
        } catch (e) {
            // ignore
        }
        
        // Höhe der Stundenzeile am Text ausrichten und an CSS-Variable binden
        function measureHoursHeight() {
            try {
                const hoursEl = document.getElementById('hours');
                if (!hoursEl) return;
                // Temporär auf auto setzen, damit Padding/Schriftgröße der Kinder die Höhe bestimmen
                const prevInlineHeight = hoursEl.style.height;
                hoursEl.style.height = 'auto';
                // Reflow forcieren und dann messen
                void hoursEl.offsetHeight;
                let maxH = Math.ceil(hoursEl.getBoundingClientRect().height);
                if (!isFinite(maxH) || maxH <= 0) { maxH = 20; }
                document.documentElement.style.setProperty('--HoursH', maxH + 'px');
                // Ursprüngliche Inline-Höhe zurücksetzen (leer lassen, damit CSS-Variable greift)
                hoursEl.style.height = prevInlineHeight && prevInlineHeight !== 'auto' ? prevInlineHeight : '';
            } catch (e) { /* ignore */ }
        }

        // Schriftgröße der Stunden automatisch verkleinern, wenn die Zellenbreite nicht ausreicht
        function autoFitHoursFont(minPx = 8) {
            try {
                const hoursEl = document.getElementById('hours');
                if (!hoursEl) return;
                // Zurück auf Standard (CSS-Variable) setzen, um die natürliche Größe zu messen
                const prevInline = hoursEl.style.fontSize;
                hoursEl.style.fontSize = '';
                void hoursEl.offsetWidth;
                // Kleinste vorhandene Zellenbreite ermitteln
                let minCellW = Infinity;
                const cells = hoursEl.children || [];
                let firstVisibleCell = null;
                for (const c of cells) {
                    if (!c) continue;
                    if (c.style.display === 'none') continue;
                    const rw = c.getBoundingClientRect().width;
                    if (rw > 0 && rw < minCellW) minCellW = rw;
                    if (!firstVisibleCell) firstVisibleCell = c;
                }
                if (!isFinite(minCellW) || minCellW <= 0) { hoursEl.style.fontSize = prevInline; return; }
                const margin = 2; // kleiner Innenabstand
                const allowed = Math.max(0, minCellW - margin);
                // Mustertext messen (2-stellige Stunde) mit gleicher writing-mode wie Zellen
                const cs = getComputedStyle(hoursEl);
                const cw = firstVisibleCell ? getComputedStyle(firstVisibleCell) : cs;
                const sample = document.createElement('span');
                sample.textContent = '88';
                sample.style.visibility = 'hidden';
                sample.style.position = 'absolute';
                sample.style.whiteSpace = 'nowrap';
                sample.style.fontSize = cs.fontSize;
                sample.style.fontFamily = cs.fontFamily;
                sample.style.writingMode = cw.writingMode || 'horizontal-tb';
                hoursEl.appendChild(sample);
                const need = sample.getBoundingClientRect().width;
                hoursEl.removeChild(sample);
                const curFs = parseFloat(cs.fontSize) || 12;
                if (need > allowed) {
                    const scale = allowed / need;
                    const newFs = Math.max(minPx, Math.floor(curFs * scale));
                    hoursEl.style.fontSize = newFs + 'px';
                } else {
                    // wenn ausreichend Platz vorhanden ist, ursprünglichen Inline-Wert zurücksetzen
                    hoursEl.style.fontSize = prevInline || '';
                }
            } catch(e) { /* ignore */ }
        }
        // Höhe der Preise-Zeile am Text ausrichten und an CSS-Variable binden
        function measurePricesHeight() {
            try {
                const pricesEl = document.getElementById('prices');
                if (!pricesEl) return;
                const prevInlineHeight = pricesEl.style.height;
                pricesEl.style.height = 'auto';
                void pricesEl.offsetHeight;
                let h = Math.ceil(pricesEl.getBoundingClientRect().height);
                if (!isFinite(h) || h <= 0) { h = 20; }
                document.documentElement.style.setProperty('--PricesH', h + 'px');
                pricesEl.style.height = prevInlineHeight && prevInlineHeight !== 'auto' ? prevInlineHeight : '';
            } catch (e) { /* ignore */ }
        }


        // Nach Layoutänderungen Gradienten vertikal neu an die Containerhöhe ausrichten
        function repositionGradients() {
            try {
                const barsEl = document.getElementById('bars');
                if (!barsEl) return;
                const rect = barsEl.getBoundingClientRect();
                const H = Math.ceil(rect.height || 0);
                if (!isFinite(H) || H <= 0) {
                    // Noch keine stabile Höhe -> im nächsten Frame erneut versuchen
                    window.requestAnimationFrame(repositionGradients);
                    return;
                }
                document.documentElement.style.setProperty('--BarsHeightPx', H + 'px');
                const dataset = Array.isArray(lastDataset) ? lastDataset : [];
                const hoursN = (typeof lastHoursToShow === 'number' && lastHoursToShow > 0) ? lastHoursToShow : 24;
                const bph    = (typeof lastBarsPerHour === 'number' && lastBarsPerHour > 0) ? lastBarsPerHour : 4;
                const expectedBars = Math.min(dataset.length, hoursN * bph);
                const viewMin = lastLocalMin;
                const viewMax = lastLocalMax;
                if (!isFinite(viewMin) || !isFinite(viewMax)) return;
                const fullRange = (viewMax - viewMin) || 1;
                function yPctFor(val) {
                    let t = (val - viewMin) / fullRange; // 0..1
                    if (!isFinite(t)) t = 0;
                    t = Math.max(0, Math.min(1, t));
                    return 100 * (1 - t); // 0% oben, 100% unten
                }
                const y0 = Math.max(0, Math.min(100, lastBaselineTopPct));
                for (let i = 0; i < expectedBars; i++) {
                    const row = dataset[i];
                    const bar = document.getElementById('bar_' + i);
                    if (!bar) continue;
                    const fill = bar.firstElementChild || bar.querySelector('.bar-inner');
                    if (!fill) continue;
                    const pNum = (row && typeof row.price === 'number') ? row.price : NaN;
                    const hasLevel = !!(row && typeof row.level === 'string' && row.level !== '');
                    const baseNoData = !isFinite(pNum) || (row && row.nodata === true);
                    const noPrice = baseNoData || (pNum === 0 && !hasLevel);
                    if (noPrice) continue;
                    let bgPosY = 0;
                    if (viewMin >= 0) {
                        // Bei rein positiven Bereichen den Verlauf am unteren Rand verankern
                        fill.style.backgroundPosition = 'left bottom';
                    } else {
                        const yP = yPctFor(pNum);
                        if (pNum >= 0) {
                            const heightPct = Math.max(0, y0 - yP);
                            const topPct = Math.max(0, y0 - heightPct);
                            bgPosY = - (H * topPct / 100);
                        } else {
                            const topPct = y0;
                            bgPosY = - (H * topPct / 100);
                        }
                    }
                    if (viewMin < 0) {
                        fill.style.backgroundPosition = '0px ' + bgPosY + 'px';
                    }
                }
            } catch(e) { /* ignore */ }
        }


        // Overlay-Funktion außerhalb von handleMessage definieren
        function rebuildOverlay() {
            try {
                const overlay = document.getElementById('avgoverlay');
                if (!overlay) return;
                overlay.innerHTML = '';
                let overlayRect = overlay.getBoundingClientRect();
                let baselineBottomPx = (overlayRect.height * ((100 - lastBaselineTopPct) / 100)) + 5; // 5px Abstand oberhalb der Nulllinie
                // Rasterlinien zeichnen: bei Maximalpreis und alle 5ct bis lokalem Minimum
                const range = lastLocalMax - lastLocalMin;
                const safeRange = range === 0 ? 1 : range;
                let vertPad = 0; // Mapping ohne zusätzlichen Puffer, ausgerichtet an der Baseline
                function yForPrice(p) {
                    // Lineare Abbildung mit Innenabstand: [lastLocalMin..lastLocalMax] -> [pad..H-pad]
                    const span = (lastLocalMax - lastLocalMin) || 1;
                    let t = (p - lastLocalMin) / span; // 0..1
                    if (!isFinite(t)) t = 0;
                    t = Math.max(0, Math.min(1, t));
                    const innerPadPx = 6; // vertikaler Innenabstand
                    const usable = Math.max(1, overlayRect.height - innerPadPx * 2);
                    const y = innerPadPx + (1 - t) * usable;
                    return Math.max(0, Math.min(overlayRect.height - 1, y));
                }
                if (!ShowGrid) {
                    // Kein Raster: linken Gutter minimieren
                    document.documentElement.style.setProperty('--LeftGutter', '0px');
                } else {
                    // Messdurchlauf: maximale Labelbreite ermitteln
                    const measureBox = document.createElement('div');
                    measureBox.style.position = 'absolute';
                    measureBox.style.visibility = 'hidden';
                    measureBox.style.left = '0px';
                    measureBox.style.top = '0px';
                    overlay.appendChild(measureBox);

                    // Max. Labelhöhe ermitteln (für sauberes Zentrieren ohne Abschneiden)
                    let maxLabelH = 0;
                    const sample = document.createElement('div');
                    sample.className = 'gridprice';
                    sample.style.top = '0px';
                    sample.style.left = '0px';
                    sample.style.width = 'auto';
                    sample.textContent = '000.00 ct';
                    measureBox.appendChild(sample);
                    maxLabelH = Math.max(maxLabelH, sample.offsetHeight || 0);

                    // Dynamischer Schritt: 5ct (Standard), bei zu dichter Beschriftung auf 10ct erhöhen
                    const eps = 1e-6;
                    function generateGridLabels(stepVal) {
                        const arr = [];
                        function pushUniqueLocal(price) {
                            for (const it of arr) {
                                if (Math.abs(it.price - price) < eps) return;
                            }
                            arr.push({ price, text: price.toFixed(BarPriceRound) + (ShowCtSuffix ? ' ct' : '') });
                        }
                        // Sichtbereich: von sichtbarem Minimum bis sichtbarem Maximum in Schrittweite
                        const start = Math.ceil((lastLocalMin + eps) / stepVal) * stepVal;
                        for (let q = start; q <= lastLocalMax + eps; q += stepVal) { pushUniqueLocal(q); }
                        return arr; // Extremwerte fügen wir separat hinzu
                    }
                    function addExtremeLabels(list) {
                        // Max immer ergänzen; Min nur bei negativen sichtbaren Min-Werten
                        const exists = (p) => list.some(it => Math.abs(it.price - p) < eps);
                        if (!exists(lastLocalMax)) list.push({ price: lastLocalMax, text: lastLocalMax.toFixed(BarPriceRound) + (ShowCtSuffix ? ' ct' : '') });
                        if (lastLocalMin < 0 && !exists(lastLocalMin)) {
                            list.push({ price: lastLocalMin, text: lastLocalMin.toFixed(BarPriceRound) + (ShowCtSuffix ? ' ct' : '') });
                        }
                        return list;
                    }
                    function minSpacingPxFor(labels) {
                        if (!labels || labels.length < 2) return Infinity;
                        const sorted = labels.slice().sort((a,b) => a.price - b.price);
                        let minPx = Infinity;
                        for (let i = 1; i < sorted.length; i++) {
                            const y1 = yForPrice(sorted[i-1].price);
                            const y2 = yForPrice(sorted[i].price);
                            const d = Math.abs(y2 - y1);
                            if (d < minPx) minPx = d;
                        }
                        return minPx;
                    }
                    // Dynamische Schrittweite: Standard 5 ct. Bei zu dichter Beschriftung -> 10 ct, bei zu großem Abstand -> 2.5 ct
                    let step = 5; // ct (Standard)
                    // Dichteprüfung ausschließlich auf regulären Rasterlabels (ohne Extremwerte)
                    let gridOnly = generateGridLabels(step);
                    const spacingDenseThreshold  = Math.max(4, (maxLabelH || 0) + 1);      // Labels dürfen sich nicht berühren
                    const spacingSparseThreshold = Math.max(spacingDenseThreshold * 3, 60); // wenn Abstand sehr groß ist -> dichteres Raster
                    const spacing5 = minSpacingPxFor(gridOnly);
                    if (spacing5 < spacingDenseThreshold) {
                        step = 10; // dichter -> Schritt erhöhen
                        gridOnly = generateGridLabels(step);
                    } else if (spacing5 > spacingSparseThreshold) {
                        step = 2.5; // zu viel Luft -> Schritt verkleinern
                        gridOnly = generateGridLabels(step);
                        // Sicherheitscheck: falls jetzt zu dicht geworden, wieder auf 5 ct zurück
                        if (minSpacingPxFor(gridOnly) < spacingDenseThreshold) {
                            step = 5;
                            gridOnly = generateGridLabels(step);
                        }
                    }
                    // Für die tatsächliche Darstellung: Rasterlabels + Extremwerte kombinieren
                    let labelsToMeasure = addExtremeLabels(gridOnly.slice());

                    // Labelbreite messen
                    let maxLabelW = 0;
                    for (const item of labelsToMeasure) {
                        const tmp = document.createElement('div');
                        tmp.className = 'gridprice';
                        tmp.style.top = '0px';
                        tmp.style.left = '0px';
                        tmp.style.width = 'auto'; // intrinsische Breite messen, unabhängig vom Gutter
                        tmp.textContent = item.text;
                        measureBox.appendChild(tmp);
                        maxLabelW = Math.max(maxLabelW, tmp.offsetWidth);
                    }
                    measureBox.remove();
                    const safeHalfY = Math.ceil((maxLabelH || 0) / 2) + 4; // zusätzliche Luft nur für Sichtbarkeit, nicht fürs Mapping
                    vertPad = 0; // Mapping bleibt unverändert, Labels dürfen überstehen (overflow-y: visible)
                    const labelPadding = 6; // px Innenabstand
                    const newGutter = Math.ceil(maxLabelW + labelPadding);
                    if (Math.abs(newGutter - lastLeftGutterPx) > 1) {
                        lastLeftGutterPx = newGutter;
                        document.documentElement.style.setProperty('--LeftGutter', newGutter + 'px');
                        // Nach Layout-Shift neu rendern
                        window.requestAnimationFrame(rebuildOverlay);
                        return;
                    }

                    // Jetzt echte Linien + Labels innerhalb des Overlays rendern (links im Gutter)
                    const createdLabels = [];
                    for (const item of labelsToMeasure) {
                        const isMax = Math.abs(item.price - lastLocalMax) < eps;
                        const isMin = Math.abs(item.price - lastLocalMin) < eps;
                        let y = yForPrice(item.price);
                        // Extremwerte exakt an die Kanten legen
                        if (isMax) y = 0;
                        if (isMin) y = overlayRect.height - 1;
                        const isExtreme = isMax || isMin;
                        if (Math.abs(item.price) < eps && !isExtreme) { continue; } // keine Linie auf der Nulllinie, außer Min/Max
                        const line = document.createElement('div');
                        line.className = 'gridline' + (isExtreme ? ' gridline-max' : '');
                        line.style.top = y + 'px';
                        // Für Min/Max: Linie nur bis zum rechten Rand des entsprechenden Balkens zeichnen
                        if (isExtreme) {
                            // ermitteln, ob es sich um Max oder Min handelt
                            let targetIdx = -1;
                            if (Math.abs(item.price - lastLocalMax) < eps) targetIdx = lastIndexMaxBar;
                            else if (Math.abs(item.price - lastLocalMin) < eps) targetIdx = lastIndexMinBar;
                            const targetBar = (targetIdx >= 0) ? document.getElementById('bar_' + targetIdx) : null;
                            if (targetBar) {
                                const rBar = targetBar.getBoundingClientRect();
                                // Linie soll ganz links beginnen (0) und bis zum rechten Rand des Zielbalkens gehen
                                const wPx = Math.max(0, (rBar.right - overlayRect.left));
                                line.style.left = '0px';
                                line.style.width = wPx + 'px';
                            }
                        }
                        overlay.appendChild(line);
                        const lbl = document.createElement('div');
                        lbl.className = 'gridprice';
                        lbl.style.top = y + 'px';
                        lbl.style.textAlign = 'right'; // ensure right alignment even on first render
                        lbl.textContent = item.text;
                        overlay.appendChild(lbl);
                        // Label vertikal zentrieren: Höhe messen und Position anpassen
                        try {
                            const lh = lbl.offsetHeight || 0;
                            if (lh > 0) {
                                // zentrieren und an den Overlay-Rändern einklemmen, damit nichts abgeschnitten wird
                                let tp = y - (lh / 2);
                                // Für Extremwerte Abstand zur Linie vergrößern: Max nach unten, Min nach oben
                                const isMax = Math.abs(item.price - lastLocalMax) < eps;
                                const isMin = Math.abs(item.price - lastLocalMin) < eps;
                                let extremeGap = 10; // Default px Abstand zur Linie
                                try {
                                    const cssGap = getComputedStyle(document.documentElement).getPropertyValue('--ExtremeLabelGap');
                                    const parsed = parseFloat(cssGap);
                                    if (isFinite(parsed)) extremeGap = parsed;
                                } catch(e) { /* ignore */ }
                                if (isMax) tp += extremeGap; // bewege von der oberen Kante weg
                                if (isMin) tp -= extremeGap; // bewege von der unteren Kante weg
                                if (tp < 0) tp = 0;
                                const maxTop = (overlayRect.height - lh);
                                if (tp > maxTop) tp = maxTop;
                                lbl.style.top = tp + 'px';
                                lbl.style.transform = 'none'; // CSS transform überschreiben
                            }
                        } catch(e) { /* ignore */ }
                        createdLabels.push({ el: lbl, line: line, y, isExtreme });
                    }
                    // Überlappungen auflösen: wenn Min/Max-Label mit Nachbar überlappt, blende das nicht-extreme Label aus
                    try {
                        createdLabels.sort((a,b)=>a.y - b.y);
                        for (let i = 1; i < createdLabels.length; i++) {
                            const prev = createdLabels[i-1];
                            const cur  = createdLabels[i];
                            const rPrev = prev.el.getBoundingClientRect();
                            const rCur  = cur.el.getBoundingClientRect();
                            if (rPrev.bottom > rCur.top) {
                                if (cur.isExtreme && !prev.isExtreme) {
                                    // Verstecke Label und zugehörige Linie des nicht-extremen Eintrags
                                    prev.el.style.visibility = 'hidden';
                                    if (prev.line) prev.line.style.visibility = 'hidden';
                                } else if (prev.isExtreme && !cur.isExtreme) {
                                    cur.el.style.visibility = 'hidden';
                                    if (cur.line) cur.line.style.visibility = 'hidden';
                                }
                            }
                        }
                    } catch(e) { /* ignore */ }
                    // Dediziertes Preislabel an der Nulllinie (ohne Linie)
                    try {
                        // Nur anzeigen, wenn 0 im sichtbaren Bereich liegt
                        if (0 >= lastLocalMin - eps && 0 <= lastLocalMax + eps) {
                            const y0 = yForPrice(0);
                            const zeroLbl = document.createElement('div');
                            zeroLbl.className = 'gridprice';
                            zeroLbl.textContent = (0).toFixed(BarPriceRound) + (ShowCtSuffix ? ' ct' : '');
                            zeroLbl.style.top = y0 + 'px';
                            zeroLbl.style.textAlign = 'right'; // ensure right alignment on first render
                            overlay.appendChild(zeroLbl);
                            // zentrieren und Rand-Clamping
                            const lh0 = zeroLbl.offsetHeight || 0;
                            if (lh0 > 0) {
                                let tp0 = y0 - (lh0 / 2);
                                if (tp0 < 0) tp0 = 0;
                                const maxTop0 = (overlayRect.height - lh0);
                                if (tp0 > maxTop0) tp0 = maxTop0;
                                zeroLbl.style.top = tp0 + 'px';
                                zeroLbl.style.transform = 'none';
                            }
                        }
                    } catch(e) { /* ignore */ }
                }
                if (BarShowPrices) {
                    for (let h = 0; h < lastHoursToShow; h++) {
                        const hourEl = document.getElementById('hour_' + h);
                        if (hourEl && hourEl.style.display === 'none') { continue; }
                        const firstIdx = h * lastBarsPerHour;
                        const lastIdx  = firstIdx + (lastBarsPerHour - 1);
                        // Bei eingeschaltetem Filter nur sichtbare Balken zur Zentrierung heranziehen
                        let firstVisible = null;
                        let lastVisible = null;
                        for (let q = 0; q < lastBarsPerHour; q++) {
                            const idx = firstIdx + q;
                            const el = document.getElementById('bar_' + idx);
                            if (el && el.style.display !== 'none') {
                                if (!firstVisible) firstVisible = el;
                                lastVisible = el;
                            }
                        }
                        if (!firstVisible || !lastVisible) { continue; }
                        const r1 = firstVisible.getBoundingClientRect();
                        const r2 = lastVisible.getBoundingClientRect();
                        const centerX = (r1.left + r2.right) / 2;
                        const label = document.createElement('div');
                        label.className = 'avglabel';
                        label.style.left = (centerX - overlayRect.left) + 'px';
                        label.style.bottom = baselineBottomPx + 'px';
                        label.style.top = '';
                        // Nur bei 15-Minuten-Daten (>=4 Balken pro Stunde) den Durchschnitt mit "Ø" anzeigen
                        let prefix = '';
                        let value = 0;
                        if (lastBarsPerHour >= 4) {
                            prefix = 'Ø ';
                            value = (lastHourAverages[h] || 0);
                        } else {
                            // Stundenpreis: tatsächlichen Preis des Balkens ohne Ø anzeigen
                            let p = (lastHourAverages[h] || 0);
                            try {
                                const attr = firstEl.getAttribute('data-price');
                                const parsed = parseFloat(attr);
                                if (isFinite(parsed)) p = parsed;
                            } catch(e) { /* ignore */ }
                            value = p;
                        }
                        label.textContent = prefix + value.toFixed(BarPriceRound) + (ShowCtSuffix ? ' ct' : '');
                        // Wenn für diese Stunde (alle 4/1 Balken) noch keine Daten existieren: Label abblenden
                        let hourHasDomData = false;
                        try {
                            for (let q = 0; q < lastBarsPerHour; q++) {
                                const idx = firstIdx + q;
                                const barEl = document.getElementById('bar_' + idx);
                                if (!barEl || barEl.style.display === 'none') continue;
                                // Platzhalter-Balken (data-nodata='1') nicht als vorhandene Daten zählen
                                const nd = barEl.getAttribute('data-nodata');
                                if (nd === '1') { continue; }
                                const attr = barEl.getAttribute('data-price');
                                const parsed = parseFloat(attr);
                                if (attr !== null && isFinite(parsed)) { hourHasDomData = true; break; }
                            }
                        } catch(e) { /* ignore */ }
                        const hasData = hourHasDomData || lastHourHasData[h];
                        if (!hasData) {
                            label.style.opacity = '0.3';
                        }
                        overlay.appendChild(label);
                        // Nach dem Einfügen: Schrift automatisch verkleinern
                        //  - Bei 15-Minuten-Preisen (>=4 Balken/Stunde): verfügbare Breite = gesamte Stundenbreite (alle 4 Balken)
                        //  - Sonst: verfügbare Breite = Breite eines einzelnen Balkens
                        try {
                            window.requestAnimationFrame(() => {
                                try {
                                    const firstBar = document.getElementById('bar_' + firstIdx);
                                    const lastBar  = document.getElementById('bar_' + lastIdx);
                                    let barW = 0;
                                    if (firstBar) {
                                        barW = firstBar.getBoundingClientRect().width;
                                    }
                                    if ((!barW || barW <= 0) && lastBar) {
                                        barW = lastBar.getBoundingClientRect().width;
                                    }
                                    if (barW > 0) {
                                        const lr = label.getBoundingClientRect();
                                        const margin = 1; // kleiner Sicherheitsabstand links/rechts
                                        let allowed = Math.max(0, barW - margin);
                                        // Bei 15-Minuten (>=4 Balken): 4x Balkenbreite als verfügbarer Raum
                                        if (lastBarsPerHour >= 4) {
                                            allowed = Math.max(0, (barW * 4) - margin);
                                        }
                                        if (lr.width > allowed) {
                                            const curFs = parseFloat(getComputedStyle(label).fontSize) || 12;
                                            const scale = allowed / lr.width;
                                            const newFs = Math.max(8, Math.floor(curFs * scale));
                                            label.style.fontSize = newFs + 'px';
                                        }
                                    }
                                } catch(e) { /* ignore */ }
                            });
                        } catch(e) { /* ignore */ }
                    }
                }
            } catch (e) {
                // ignore
            }
        }
        // Bei Größenänderung neu messen und neu positionieren
        window.addEventListener('resize', () => window.requestAnimationFrame(() => { try { autoFitHoursFont(); } catch(e) {} try { measureHoursHeight(); } catch(e) {} try { measurePricesHeight(); } catch(e) {} try { rebuildOverlay(); } catch(e) {} try { repositionGradients(); } catch(e) {} }));
    </script>
</body>
</html>